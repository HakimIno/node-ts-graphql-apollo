"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkJoiIsCompatible = exports.IncompatibleJoiVersion = exports.getJoiVersion = exports.parseVersionString = exports.updateWorkingSchema = exports.getJoiSchema = exports.getMergedWorkingSchemas = exports.getWorkingSchema = exports.JOI_VERSION = exports.SCHEMA_KEY = exports.WORKING_SCHEMA_KEY = exports.getJoi = void 0;
require("reflect-metadata");
const Joi = require("joi");
const getJoi = (options = {}) => options.joi || Joi;
exports.getJoi = getJoi;
exports.WORKING_SCHEMA_KEY = 'tsdv:working-schema';
exports.SCHEMA_KEY = 'tsdv:schema';
exports.JOI_VERSION = getJoiVersion(Joi);
function getWorkingSchema(target) {
    let workingSchema = Reflect.getOwnMetadata(exports.WORKING_SCHEMA_KEY, target);
    return workingSchema;
}
exports.getWorkingSchema = getWorkingSchema;
function getMergedWorkingSchemas(target) {
    const parentPrototype = Object.getPrototypeOf(target);
    const parentSchema = (parentPrototype &&
        (parentPrototype.constructor !== Object) &&
        getMergedWorkingSchemas(parentPrototype));
    const workingSchema = getWorkingSchema(target);
    if (workingSchema || parentSchema) {
        return Object.assign(Object.assign({}, parentSchema), workingSchema);
    }
    return undefined;
}
exports.getMergedWorkingSchemas = getMergedWorkingSchemas;
function getJoiSchema(Class, joi) {
    const isSchemaDefined = Reflect.hasOwnMetadata(exports.SCHEMA_KEY, Class.prototype);
    if (isSchemaDefined) {
        return Reflect.getOwnMetadata(exports.SCHEMA_KEY, Class.prototype);
    }
    let workingSchema = getMergedWorkingSchemas(Class.prototype);
    const joiSchema = (workingSchema ? joi.object().keys(workingSchema) : undefined);
    Reflect.defineMetadata(exports.SCHEMA_KEY, joiSchema, Class.prototype);
    return joiSchema;
}
exports.getJoiSchema = getJoiSchema;
function updateWorkingSchema(target, propertyKey, schema) {
    let workingSchema = getWorkingSchema(target);
    if (!workingSchema) {
        workingSchema = {};
        Reflect.defineMetadata(exports.WORKING_SCHEMA_KEY, workingSchema, target);
    }
    workingSchema[String(propertyKey)] = schema;
}
exports.updateWorkingSchema = updateWorkingSchema;
function parseVersionString(version) {
    const [major, minor, patch] = (version).split('.');
    return {
        major: major || '',
        minor: minor || '',
        patch: patch || '',
    };
}
exports.parseVersionString = parseVersionString;
function getJoiVersion(joi) {
    const versionString = (joi || {})['version'] || '?.?.?';
    return parseVersionString(versionString);
}
exports.getJoiVersion = getJoiVersion;
class IncompatibleJoiVersion extends Error {
    constructor(actualVersion) {
        super(`Cannot use Joi v${actualVersion} with Joiful. Joiful requires Joi v${exports.JOI_VERSION.major}.x.x`);
    }
}
exports.IncompatibleJoiVersion = IncompatibleJoiVersion;
function checkJoiIsCompatible(joi) {
    if (joi) {
        const actualVersion = getJoiVersion(joi);
        if (exports.JOI_VERSION.major !== actualVersion.major) {
            throw new IncompatibleJoiVersion(actualVersion);
        }
    }
}
exports.checkJoiIsCompatible = checkJoiIsCompatible;
//# sourceMappingURL=core.js.map